<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html lang="es-es">
<head>
<!-- saved from url=(0073)http://dis.unal.edu.co/~fgonza/courses/2004-I/AI/PRACTICAS_DE_PROLOG.html -->
  <title>PRACTICAS DE PROLOG</title>
  <meta http-equiv="Content-Type"
 content="text/html; charset=windows-1252">
  <meta content="Microsoft FrontPage 5.0" name="GENERATOR">
</head>
<body lang="ES" link="blue" vlink="purple">
<div class="Section1">
<h1><b>Introducción a PROLOG<o =""></o></b></h1>
<p><b><o:p>&nbsp;Autor: Daniel Penagos (Modificado por Johann Camilo
Olarte D.)<br>
</o:p></b></p>
<h2><b>Contenido:</b><b>&nbsp;</b></h2>
<ol>
  <li><a href="#generalidades"><b>Generalidades sobre Prolog.</b> </a>
    <ol>
      <li><a href="#formasminimas"><b>Formas Mínimas en Prolog.</b> </a>
      </li>
      <li><b><a href="#relaciones">Las Relaciones.</a></b> </li>
      <li><b><a href="#predicadoshyr">Predicados, Hechos y Reglas.</a></b>
      </li>
      <li><a href="#listas"><b>Listas.</b> </a> </li>
    </ol>
  </li>
  <li><a style="font-weight: bold;" href="#PRACTICA0">Práctica 0.</a></li>
  <li><a href="#practica1"><b>Práctica 1.</b> </a> </li>
  <li><a href="#practica2"><b>Práctica 2.</b> </a> </li>
  <li><a href="#practica3"><b>Práctica 3.</b></a></li>
  <li><b><a href="#practica4">Práctica 4.</a><br>
    </b></li>
  <li><b><a href="#vinculos">Vínculos.</a></b> </li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2><a name="generalidades"><b>GENERALIDADES SOBRE PROLOG:</b></a></h2>
<p><b></b>&nbsp;</p>
<p>La programación lógica surge hacia 1979 donde Kowalski
establece el
enunciado del patrón de programación lógica:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Algoritmo + lógica + control</p>
<p>La programación lógica involucra:</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; El uso
de hechos y reglas y la construcción de deducciones para
procesar
consultas.</p>
<p>&nbsp;</p>
<h3><a name="formasminimas"><u>Formas Mínimas en </u></a><u>Prolog</u><u>:</u></h3>
<p>Corresponden a las formas más sencillas de información
manipulada
por Prolog:</p>
<ol>
  <li>Los átomos de información.: una cadena de texto que
empieza por
letra minúscula o un valor numérico con signo opcional</li>
  <li>Las variables: Son cadenas de texto que empiezan por una letra
mayúscula o&nbsp; por el signo _ (underscore).</li>
</ol>
<p>&nbsp;</p>
<h3><a name="relaciones"><u>Las Relaciones: </u></a></h3>
<p>Con las formas mínimas anteriormente descritas se pueden
construir
las relaciones, base del conocimiento en Prolog.</p>
<p>Ejemplos de relaciones:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
 style="font-family: courier new,courier,monospace;">padre(pepe, maria).</span>
// en esta relación se denota una existencia de parentesco entre
pepe y
maria, prolog en este punto no conoce </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//quien es el padre de quien, somos nosotros quienes le damos esa
interpretación, prolog solamente se encarga de </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//crear una relación en su base del
conocimiento.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp; Obsérvese la sintaxis de la relación
descrita: </p>
<ul>
  <li>Nótese que los nombres de las personas empiezan por letras
minúsculas indicando que son átomos de información
y variables. </li>
  <li>El nombre de la relación es también un átomo
de información
y&nbsp; no debe ser una cantidad numérica. </li>
  <li>Número de objetos relacionados: sin son cero irán
entre
paréntesis y si son mas de uno, irán separados por comas. </li>
  <li>Los hechos terminan siempre en punto. (.) </li>
</ul>
<p>&nbsp;</p>
<p>Al tener por ejemplo dentro de nuestra base del conocimiento, los
siguientes hechos:</p>
<p><span style="font-family: courier new,courier,monospace;">sucesor(1,2).</span></p>
<p style="font-family: courier new,courier,monospace;">sucesor(2,3).</p>
<p style="font-family: courier new,courier,monospace;">sucesor(3,4).</p>
<p style="font-family: courier new,courier,monospace;">sucesor(4,5).</p>
<p style="font-family: courier new,courier,monospace;">sucesor(5,6).</p>
<p style="font-family: courier new,courier,monospace;">sucesor(6,7).</p>
<p>Podemos realizar consultas como las siguientes: </p>
<p style="font-family: courier new,courier,monospace;">sucesor(X,6).</p>
<p style="font-family: courier new,courier,monospace;">sucesor(2,Y).</p>
<p style="font-family: courier new,courier,monospace;">sucesor(X,Y).</p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Nótese como los átomos de información que se
desean consultar han sido
reemplazados por variables (letra inicial en mayúscula); en este
punto
Prolog busca dentro de su base del conocimiento un hecho que haga
emparejamiento con la información suministrada en la consulta.
Primero,
busca una predicado (nombre de la relación) llamado sucesor,
luego hace
una comparación entre la información que se tiene (6),
para llenar la
variable X con la información almacenada en el hecho,
así, prolog
responde X=5. De la misma forma ocurre con la segunda consulta; en la
tercera no existe información para hacer emparejamiento en la
base del
conocimiento, por lo tanto el responderá con el primer hecho que
tenga
ese predicado. </p>
<p>Responderá:</p>
<p>X = 1</p>
<p>Y = 2;</p>
<p>En este punto tenemos dos opciones: quedar satisfechos con la
respuesta que prolog nos ha suministrado oprimiendo enter o solicitarle
consultas sobre otros posibles emparejamientos, para la cual debemos
oprimir punto y coma (;).<br>
&nbsp;</p>
<p>Es también posible construir en prolog consultas complejas
con los
operadores AND(,), OR(;) y NOT(not) de la siguiente forma:</p>
<p style="font-family: courier new,courier,monospace;">legusta(pepe,pesca).</p>
<p style="font-family: courier new,courier,monospace;">legusta(maria,bailar).</p>
<p style="font-family: courier new,courier,monospace;">legusta(ana,pesca).</p>
<p style="font-family: courier new,courier,monospace;">legusta(pepe,musica).</p>
<p style="font-family: courier new,courier,monospace;">legusta(maria,musica).</p>
<p style="font-family: courier new,courier,monospace;">legusta(ana,bailar).</p>
<p>&nbsp;</p>
<p>&nbsp; Se pueden realizar las siguientes preguntas sobre la base de
información:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -
¿Le gusta la música a Pepe y a Maria?
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
 style="font-family: courier new,courier,monospace;">?-legusta(pepe,musica),legusta(maria,musica).</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -
¿Le gusta bailar a Pepe o a Maria le gusta la
música?:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<span style="font-family: courier new,courier,monospace;">?-legusta(pepe,musica);legusta(maria,musica).</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -
¿Le gusta bailar a Pepe y a Maria no le gusta la
música?:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
 style="font-family: courier new,courier,monospace;">?-legusta(pepe,musica),not(legusta(maria,musica)).</span></p>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Para que estas consultas funcionen de forma adecuada es necesario no
dejar espacios entre los operadores.</p>
<p>&nbsp;</p>
<h3><a name="predicadoshyr"><u>Predicados, Hechos y Reglas:</u></a></h3>
<p>En este caso la relación &nbsp;<i>padre(</i><i>pepe, maria). </i>&nbsp;se
asume como un hecho, pues no está involucrando variables en su
definición; al nombre de la relación se le llama
predicado.</p>
<p>Mas formalmente un predicado es un conjunto de hechos o reglas que
tienen un mismo nombre y la misma cantidad de objetos relacionados, si
se trata de reglas, en nombre de la conclusión es el mismo
y&nbsp; el
número de objetos relacionados es también el mismo.</p>
<p>Una regla es una sola conclusión seguida por el signo
:-&nbsp; el
cual hace la vez de SI condicional, seguida por una o mas relaciones de
condición.</p>
<p>Por ejemplo: </p>
<p>&nbsp;</p>
<p style="font-family: courier new,courier,monospace;">sucesor(1,2).</p>
<p style="font-family: courier new,courier,monospace;">sucesor(2,3).</p>
<p style="font-family: courier new,courier,monospace;">sucesor(3,4).</p>
<p style="font-family: courier new,courier,monospace;">sucesor(4,5).</p>
<p style="font-family: courier new,courier,monospace;">sucesor(5,6).</p>
<p style="font-family: courier new,courier,monospace;">sucesor(6,7).</p>
<p style="font-family: courier new,courier,monospace;">suma(1,X,R):-sucesor(X,R).</p>
<p style="font-family: courier new,courier,monospace;">suma(N,X,R):-sucesor(M,N),suma(M,X,R1),sucesor(R1,R).</p>
<p>&nbsp;</p>
<p>Aquí podemos apreciar como <span
 style="font-style: italic; font-family: courier new,courier,monospace;">suma</span>
es una regla que depende en gran medida de la condición <span
 style="font-style: italic; font-family: courier new,courier,monospace;">sucesor</span>.
En la segunda regla de suma se observa que existe mas de una
condición,
por tanto estas van separadas por coma; podemos observar también
que se
realiza una operación recursiva. Esta misma sentencia traducida
en un
lenguaje de programación como Java quedaría:</p>
<span style="font-family: courier new,courier,monospace;">int suma(int
N, int X, int R) </span><br
 style="font-family: courier new,courier,monospace;">
<span style="font-family: courier new,courier,monospace;">{ </span><br
 style="font-family: courier new,courier,monospace;">
<span style="font-family: courier new,courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if ( N == 1 ) </span><br
 style="font-family: courier new,courier,monospace;">
<span style="font-family: courier new,courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ </span><br style="font-family: courier new,courier,monospace;">
<span style="font-family: courier new,courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sucesor(X,R); </span><br
 style="font-family: courier new,courier,monospace;">
<span style="font-family: courier new,courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} </span><br style="font-family: courier new,courier,monospace;">
<span style="font-family: courier new,courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else </span><br style="font-family: courier new,courier,monospace;">
<span style="font-family: courier new,courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ </span><br style="font-family: courier new,courier,monospace;">
<span style="font-family: courier new,courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sucesor(M,N); </span><br
 style="font-family: courier new,courier,monospace;">
<span style="font-family: courier new,courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
suma(M,X,R1); </span><br
 style="font-family: courier new,courier,monospace;">
<span style="font-family: courier new,courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sucesor(R1,R2); </span><br
 style="font-family: courier new,courier,monospace;">
<span style="font-family: courier new,courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} </span><br style="font-family: courier new,courier,monospace;">
<span style="font-family: courier new,courier,monospace;">}</span>
<p>Obsérvese que en la segunda línea del bloque else se
realiza un
llamado recursivo al método suma, de forma tal, que se realiza
la
operación disminuyendo el valor de N hasta que este se hace 1,
en el
cual termina la recursividad y se origina la respuesta.</p>
<p>&nbsp;</p>
<h3><a name="listas"><u>Listas</u></a></h3>
<p>Una lista en prolog es una secuencia lineal de objetos, con la
característica de que toda la manipulación de la
secuencia se realiza
por el extremo izquierdo, debido a la forma como se representa una
lista generalizada.</p>
<p>Una lista vacía se representa de la siguiente
manera:&nbsp;&nbsp;&nbsp;&nbsp; []</p>
<p>Una lista generalizada, con un número de objetos distinto de
0
:&nbsp;&nbsp;&nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [X|Y]&nbsp;&nbsp;&nbsp; // en esta
lista se está declarando por lo menos un objeto X y una
secuencia de
objetos a la derecha de X, pudiendo ser incluso una lista vacía.</p>
<p>De igual manera, la lista&nbsp;&nbsp; [X,Y|Z] contiene por lo menos
dos objetos: X y Y, seguidos de una secuencia de objetos Z, la cual
puede ser vacía.</p>
<p>La notación se extiende de esta manera, para una lista con
por lo
menos tres objetos, su representación sería la siguiente:
[X,Y,Z|W]</p>
<p>&nbsp;</p>
<p>Ejemplo de manipulación de listas: se quiere a una lista
agregar
otra lista al final, de esta forma, si la primera lista es [a,b,c]
y&nbsp; la segunda es [d,e,f], la lista resultante sería:
[a,b,c,d,e,f].</p>
<p>&nbsp;</p>
<p>El programa que realiza esto en prolog sería:</p>
<p>&nbsp;</p>
<p style="font-family: courier new,courier,monospace;">agregar([],L,L).</p>
<p style="font-family: courier new,courier,monospace;">agregar([A|R],L,[A|T]):-agregar(R,L,T).</p>
<p>&nbsp;</p>
<p>En este programa nuevamente vemos la recursión en la segunda
línea:
se va disminuyendo el tamaÃ±o de la primera lista hasta
que este es
cero, en cuyo caso finaliza la recursión y se origina una
respuesta.
Observamos que los elementos en la regla son: lista inicial, lista que
se adiciona, lista final.</p>
<p>&nbsp;</p>
<h2><a name="PRACTICA0"></a> PRACTICA 0:</h2>
<ol>
  <li>Descargue e instale SWI-Prolog <b><a
 href="http://www.swi.psy.uva.nl/cgi-bin/nph-download/SWI-Prolog/w32pl5213.exe">http://www.swi.psy.uva.nl/cgi-bin/nph-download/SWI-Prolog/w32pl5213.exe</a></b></li>
  <li>Ejecute la aplicación.</li>
  <li>Cree un nuevo archivo usando la opción File--New (use un
nombre tal como prueba.pl)</li>
  <li>Digite:<br>
    <code>prueba(uno).<br>
prueba(dos).</code></li>
  <li>Guarde el archivo y salga del editor.</li>
  <li>Cargue el archivo usando la opción File--Consult</li>
  <li>En el prompt digite:<br>
    <code>prueba(X). &lt;enter&gt;<br>
; </code><code><br>
    </code><code>; </code><code></code><br>
    <code></code></li>
</ol>
<a name="practica1"><b>PRACTICA 1:</b> </a><br>
<p>Desarrollar su árbol genealógico en prolog mediante la
siguiente
semántica:</p>
<p style="font-family: courier new,courier,monospace;">padre(nombre_1,nombre_2).</p>
<p style="font-family: courier new,courier,monospace;">padre(nombre_3,nombre_4).</p>
<p>¦</p>
<p>¦</p>
<p>De igual manera exprese también las siguientes relaciones
usando reglas: hermano, hijo, tio, sobrino, primo, ancestro, etc. </p>
<p>De esta forma existirá información redundante en
varios sentidos que
deberá ser coherente.</p>
<p>&nbsp;</p>
<p>Realice consultas sobre la información almacenada con
preguntas
complejas construidas con los operadores AND (,), OR(;) y NOT(not).</p>
<p>&nbsp;</p>
<h2><a name="practica2"><b>PRACTICA 2</b>:</a></h2>
<p>Desarrolle un programa en prolog que resuelva el factorial de un
número,</p>
<p><span style="font-family: courier new,courier,monospace;">?-
factorial(5,S).</span><br
 style="font-family: courier new,courier,monospace;">
<span style="font-family: courier new,courier,monospace;">S = 120</span>
</p>
<p>Desarrolle un programa que calcule la suma de los primeros N cubos. </p>
<p><span style="font-family: courier new,courier,monospace;">?-
sumancubos(5,S).</span><br
 style="font-family: courier new,courier,monospace;">
<span style="font-family: courier new,courier,monospace;">S = 225</span>
</p>
<h2><a name="practica3"><b>PRACTICA 3</b>: </a></h2>
<ol>
  <li>Se tienen dos listas con el mismo número de objetos,
escriba un
programa en prolog que tome alternativamente elementos de ambas listas
para construir una nueva lista con los elementos de ambas.</li>
  <li>Desarrolle un programa que invierta el orden de los elementos de
una lista dada.</li>
</ol>
<h2><a name="practica4"><b>PRACTICA 4</b>:</a></h2>
<p>Defina un predicado <span
 style="font-family: courier new,courier,monospace;">producto(X,Y,Z)</span>
que sea verdadero si <span
 style="font-family: courier new,courier,monospace;">X*Y=Z</span>. Haga
dos implementaciones:<br>
</p>
<ol>
  <li>Utilice el predicado <span
 style="font-family: courier new,courier,monospace;">sucesor</span>
presentado anteriormente.</li>
  <li>Utilice una función <span
 style="font-family: courier new,courier,monospace;">suc()</span> y la
constante <span style="font-family: courier new,courier,monospace;">cero</span>
para definir todos los números naturlaes de la siguiente forma: <span
 style="font-family: courier new,courier,monospace;">cero, suc(cero),
suc(suc(cero))</span>, etc.<br>
  </li>
</ol>
<h2><a name="vinculos"><b>VINCULOS DE INTERES</b></a><b>:</b></h2>
<p><b><br>
&nbsp;</b></p>
<p><b>Esta es la última versión de SWI-Prolog para
Windows.</b></p>
<p><b><a
 href="http://www.swi.psy.uva.nl/cgi-bin/nph-download/SWI-Prolog/w32pl5213.exe">http://www.swi.psy.uva.nl/cgi-bin/nph-download/SWI-Prolog/w32pl5213.exe</a></b></p>
<p><b>En este vínculo se encuentran una serie de transparencias
que
ilustran los conceptos básicos de Prolog.</b></p>
<p><b><a href="http://webepcc.unex.es/agomez/prolog.htm">http://webepcc.unex.es/agomez/prolog.htm</a></b></p>
<p><b>Otro vínculo con información sobre conceptos
básicos, (se
recomiendan los archivos pdf Tema0,I,II,III,IV).</b></p>
<p><b><a href="http://polaris.lcc.uma.es/%7Epacog/apuntes/pd/">http://polaris.lcc.uma.es/~pacog/apuntes/pd/</a></b></p>
<p><b>Pdf con un buen tutorial y ejemplos de programas</b></p>
<p><b>
<a
 href="http://euitio.trisquelmedia.net/apuntes/viejo/primero/logica/Programacion%20practica%20en%20prolog.zip">http://euitio.trisquelmedia.net/apuntes/viejo/primero/logica/Programacion%20practica%20en%20prolog.zip</a></b></p>
<p><b>Programas de ejemplo:</b></p>
<p><b><a
 href="http://www.lsi.upc.es/%7Ebejar/docencia/tmia/tmia.laboratorio.html">http://www.lsi.upc.es/~bejar/docencia/tmia/tmia.laboratorio.html</a></b></p>
<p>&nbsp;</p>
</div>
</body>
</html>
